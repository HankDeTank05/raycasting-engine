Index: raycasting.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import math\nimport sys\n\nimport arcade\n\nSCREEN_WIDTH = 1280\nSCREEN_HEIGHT = 720\n\nMOVE_SPEED = 5.0\nROTATION_SPEED = 2.0\n\n\nclass RaycastingEngine(arcade.Window):\n    \"\"\"\n    This class creates an arcade window subclass, RaycastingEngine, meant for first-person games\n    \"\"\"\n\n    def __init__(self, width, height, title):\n        super().__init__(width, height, title)\n\n        # level map\n        self.map = None\n\n        # player parameters\n        self.pos_x = None\n        self.pos_y = None\n\n        self.dir_x = None\n        self.dir_y = None\n\n        self.plane_x = None\n        self.plane_y = None\n\n        # movement boolean flags\n        self.move_forward = None\n        self.move_backward = None\n        self.strafe_left = None\n        self.strafe_right = None\n        self.rotate_left = None\n        self.rotate_right = None\n\n        # performance statistics\n        self.time = None\n        self.old_time = None\n\n        # drawing\n        self.shape_list = None\n        self.point_list = None\n        self.main_wall_color_list = None\n        self.dark_wall_color_list = None\n        self.floor_color = None\n        self.ceiling_color = None\n\n        # gameplay\n        self.move_speed = None\n        self.rotation_speed = None\n        self.constant_move_speed = None\n        self.constant_rotation_speed = None\n\n    def setup(self,\n              player_start: tuple,\n              look_start: tuple,\n              plane_start: tuple,\n              level_map,\n              player_move_speed=MOVE_SPEED,\n              player_rotation_speed=ROTATION_SPEED,\n              floor_color=arcade.color.BLACK,\n              ceiling_color=arcade.color.BLACK,\n              strafe_enabled=True,\n              hide_mouse=True):\n\n        # level map\n        self.map = level_map\n\n        # player parameters\n        self.pos_x = player_start[0]\n        self.pos_y = player_start[1]\n\n        self.dir_x = look_start[0]\n        self.dir_y = look_start[1]\n\n        self.plane_x = plane_start[0]\n        self.plane_y = plane_start[1]\n\n        # movement boolean flags\n        self.move_forward = False\n        self.move_backward = False\n        if strafe_enabled:\n            self.strafe_left = False\n            self.strafe_right = False\n        self.rotate_left = False\n        self.rotate_right = False\n\n        # performance statistics\n        self.time = 0\n        self.old_time = 0\n\n        # drawing\n        self.shape_list = arcade.ShapeElementList()\n\n        self.main_wall_color_list = [\n            arcade.color.RED,\n            arcade.color.GREEN,\n            arcade.color.BLUE,\n            arcade.color.WHITE,\n            arcade.color.YELLOW,\n            arcade.color.PURPLE,\n            arcade.color.ORANGE,\n            arcade.color.PINK\n        ]\n\n        self.dark_wall_color_list = [\n            arcade.color.DARK_RED,\n            arcade.color.DARK_GREEN,\n            arcade.color.DARK_BLUE,\n            arcade.color.GRAY,\n            arcade.color.DARK_YELLOW,\n            arcade.color.DARK_PASTEL_PURPLE,\n            arcade.color.DARK_ORANGE,\n            arcade.color.DARK_PINK\n        ]\n\n        self.floor_color = floor_color\n\n        self.ceiling_color = ceiling_color\n\n        # hide the mouse by default\n        if hide_mouse:\n            self.set_exclusive_mouse(exclusive=True)\n\n        # gameplay\n        self.constant_move_speed = player_move_speed\n        self.constant_rotation_speed = player_rotation_speed\n\n    def on_update(self, delta_time):\n        # clear the shape list for the new frame\n        self.shape_list = arcade.ShapeElementList()\n\n        # set the floor and ceiling colors\n        floor = arcade.create_rectangle(\n            SCREEN_WIDTH // 2, int(SCREEN_HEIGHT * 0.25),\n            SCREEN_WIDTH, SCREEN_HEIGHT // 2,\n            self.floor_color\n        )\n\n        ceiling = arcade.create_rectangle(\n            SCREEN_WIDTH // 2, int(SCREEN_HEIGHT * 0.75),\n            SCREEN_WIDTH, SCREEN_HEIGHT // 2,\n            self.ceiling_color\n        )\n\n        # add the floor and ceiling shapes to the shape_list\n        self.shape_list.append(floor)\n        self.shape_list.append(ceiling)\n\n        # create the point_list and color_list for raycasting\n        point_list = []\n        color_list = []\n\n        # begin raycasting\n        for x in range(0, SCREEN_WIDTH + 1):\n            # calculate the ray position and direction\n            camera_x = (2 * x / SCREEN_WIDTH) - 1\n            if camera_x > 1 or camera_x < -1:\n                print('camera_x is too big or too small!')\n                print(f'camera_x = {camera_x}')\n            ray_dir_x = self.dir_x + self.plane_x * camera_x\n            ray_dir_y = self.dir_y + self.plane_y * camera_x\n\n            # determine which grid-square of the map we're in\n            map_x = int(self.pos_x)\n            map_y = int(self.pos_y)\n\n            # length of ray from the current position to the next vertical gridline\n            side_dist_x = None\n            # length of ray from the current position to the next horizontal gridline\n            side_dist_y = None\n\n            # length of the ray from one horizontal or vertical gridline to the next one\n            try:\n                delta_dist_x = abs(1 / ray_dir_x)\n            except ZeroDivisionError:\n                if ray_dir_y == 0:\n                    delta_dist_x = 0\n                elif ray_dir_x == 0:\n                    delta_dist_x = 1\n                else:\n                    delta_dist_x = abs(1 / ray_dir_x)\n\n            try:\n                delta_dist_y = abs(1 / ray_dir_y)\n            except ZeroDivisionError:\n                if ray_dir_x == 0:\n                    delta_dist_y = 0\n                elif ray_dir_y == 0:\n                    delta_dist_y = 1\n                else:\n                    delta_dist_y = abs(1 / ray_dir_y)\n\n            # the distance to the next perpendicular wall\n            perpendicular_wall_dist = None\n\n            # which direction to step in the x direction or the y direction (either +1 or -1)\n            step_x = None\n            step_y = None\n\n            # was a there a wall hit?\n            hit = 0\n\n            # was a North/South wall hit or an East/West wall hit?\n            side = None\n\n            if ray_dir_x < 0:\n                step_x = -1\n                side_dist_x = (self.pos_x - map_x) * delta_dist_x\n            else:\n                step_x = 1\n                side_dist_x = (map_x + 1 - self.pos_x) * delta_dist_x\n\n            if ray_dir_y < 0:\n                step_y = -1\n                side_dist_y = (self.pos_y - map_y) * delta_dist_y\n            else:\n                step_y = 1\n                side_dist_y = (map_y + 1 - self.pos_y) * delta_dist_y\n\n            # continually cast the ray out into the distance until it hits a wall\n            while hit == 0:\n                if side_dist_x < side_dist_y:\n                    side_dist_x += delta_dist_x\n                    map_x += step_x\n                    side = 0\n                else:\n                    side_dist_y += delta_dist_y\n                    map_y += step_y\n                    side = 1\n\n                # check if the ray has hit a wall yet\n                if self.map[map_x][map_y] > 0:\n                    hit = 1\n\n            if side == 0:\n                perpendicular_wall_dist = (map_x - self.pos_x + (1 - step_x) / 2) / (ray_dir_x + 0.00000001)\n            else:\n                perpendicular_wall_dist = (map_y - self.pos_y + (1 - step_y) / 2) / (ray_dir_y + 0.00000001)\n\n            \"\"\"\n            **********************************************\n            MODIFY CODE BELOW FOR ALLOWING PITS/HIGH WALLS\n            **********************************************\n            \"\"\"\n            # the height of the wall at the given pixel column\n            line_height = int(SCREEN_HEIGHT / (perpendicular_wall_dist + 0.00000001))\n\n            # the pixel (height) at which to start drawing the wall\n            draw_start = -line_height / 2 + SCREEN_HEIGHT / 2\n\n            if draw_start < 0:\n                draw_start = 0\n\n            draw_end = line_height / 2 + SCREEN_HEIGHT / 2\n            if draw_end >= SCREEN_HEIGHT:\n                draw_end = SCREEN_HEIGHT - 1\n\n            # set the color with which to draw the given pixel column\n            if side == 0:\n                try:\n                    color = self.main_wall_color_list[self.map[map_x][map_y]]\n                except IndexError:\n                    color = arcade.color.YELLOW\n            elif side == 1:\n                try:\n                    color = self.dark_wall_color_list[self.map[map_x][map_y]]\n                except IndexError:\n                    color = arcade.color.DARK_YELLOW\n\n            draw_start_pos = (x, draw_start)\n            draw_end_pos = (x, draw_end)\n            point_list.append(draw_start_pos)\n            point_list.append(draw_end_pos)\n            for i in range(2):\n                color_list.append(color)\n\n        shape = arcade.create_line_generic_with_colors(point_list, color_list, 3)\n        self.shape_list.append(shape)\n\n        self.old_time = self.time\n        self.time += delta_time\n\n        # frame_time is the amount of time this frame spent on screen (in seconds)\n        frame_time = (self.time - self.old_time)\n\n        FPS = 1 / frame_time\n        \"\"\"\n        ********************************************************\n        HERE IS WHERE THE CODE FOR AUTO QUALITY ADJUST SHOULD GO\n        ********************************************************\n        \"\"\"\n\n        self.move_speed = frame_time * self.constant_move_speed\n        self.rotation_speed = frame_time * self.constant_rotation_speed\n\n        if self.move_forward:\n            if not self.map[int(self.pos_x + self.dir_x * self.move_speed)][int(self.pos_y)]:\n                self.pos_x += self.dir_x * self.move_speed\n            if not self.map[int(self.pos_x)][int(self.pos_y + self.dir_y * self.move_speed)]:\n                self.pos_y += self.dir_y * self.move_speed\n        elif self.move_backward:\n            if not self.map[int(self.pos_x - self.dir_x * self.move_speed)][int(self.pos_y)]:\n                self.pos_x -= self.dir_x * self.move_speed\n            if not self.map[int(self.pos_x)][int(self.pos_y - self.dir_y * self.move_speed)]:\n                self.pos_y -= self.dir_y * self.move_speed\n\n        if self.strafe_left:\n            if not self.map[int(self.pos_x - self.dir_y * self.move_speed)][int(self.pos_y)]:\n                self.pos_x -= self.dir_y * self.move_speed\n            if not self.map[int(self.pos_x)][int(self.pos_y + self.dir_x * self.move_speed)]:\n                self.pos_y += self.dir_x * self.move_speed\n        elif self.strafe_right:\n            if not self.map[int(self.pos_x + self.dir_y * self.move_speed)][int(self.pos_y)]:\n                self.pos_x += self.dir_y * self.move_speed\n            if not self.map[int(self.pos_x)][int(self.pos_y - self.dir_x * self.move_speed)]:\n                self.pos_y -= self.dir_x * self.move_speed\n\n        if self.rotate_left:\n            # both camera direction and camera plane must be rotated\n            old_dir_x = self.dir_x\n            self.dir_x = self.dir_x * math.cos(self.rotation_speed) - self.dir_y * math.sin(self.rotation_speed)\n            self.dir_y = old_dir_x * math.sin(self.rotation_speed) + self.dir_y * math.cos(self.rotation_speed)\n            old_plane_x = self.plane_x\n            self.plane_x = self.plane_x * math.cos(self.rotation_speed) - self.plane_y * math.sin(self.rotation_speed)\n            self.plane_y = old_plane_x * math.sin(self.rotation_speed) + self.plane_y * math.cos(self.rotation_speed)\n        elif self.rotate_right:\n            # both camera direction and camera plane must be rotated\n            old_dir_x = self.dir_x\n            self.dir_x = self.dir_x * math.cos(-self.rotation_speed) - self.dir_y * math.sin(-self.rotation_speed)\n            self.dir_y = old_dir_x * math.sin(-self.rotation_speed) + self.dir_y * math.cos(-self.rotation_speed)\n            old_plane_x = self.plane_x\n            self.plane_x = self.plane_x * math.cos(-self.rotation_speed) - self.plane_y * math.sin(-self.rotation_speed)\n            self.plane_y = old_plane_x * math.sin(-self.rotation_speed) + self.plane_y * math.cos(-self.rotation_speed)\n\n    def on_draw(self):\n\n        arcade.start_render()\n\n        # draw all the shapes in the list\n        self.shape_list.draw()\n\n        \"\"\"\n        ********************************\n        INSERT MINIMAP DRAWING CODE HERE\n        ********************************\n        \"\"\"\n\n    def on_key_press(self, key, modifiers):\n        if key == arcade.key.W:\n            self.move_forward = True\n        if key == arcade.key.A:\n            self.strafe_left = True\n        if key == arcade.key.S:\n            self.move_backward = True\n        if key == arcade.key.D:\n            self.strafe_right = True\n        if key == arcade.key.LEFT:\n            self.rotate_left = True\n        if key == arcade.key.RIGHT:\n            self.rotate_right = True\n        if key == arcade.key.ESCAPE:\n            sys.exit()\n\n    def on_key_release(self, key, modifiers):\n        if key == arcade.key.W:\n            self.move_forward = False\n        if key == arcade.key.A:\n            self.strafe_left = False\n        if key == arcade.key.S:\n            self.move_backward = False\n        if key == arcade.key.D:\n            self.strafe_right = False\n        if key == arcade.key.LEFT:\n            self.rotate_left = False\n        if key == arcade.key.RIGHT:\n            self.rotate_right = False\n\n\ndef pick_map(map_number: int):\n    maps = [\n        [  # simple example map\n            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 3, 0, 3, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 3, 0, 3, 0, 3, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 4, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 4, 0, 0, 0, 0, 5, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 4, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 4, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        ],\n        [  # complex example map\n            [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7],\n            [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 7],\n            [4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7],\n            [4, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7],\n            [4, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 7],\n            [4, 0, 4, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 0, 7, 7, 7, 7, 7],\n            [4, 0, 5, 0, 0, 0, 0, 5, 0, 5, 0, 5, 0, 5, 0, 5, 7, 0, 0, 0, 7, 7, 7, 1],\n            [4, 0, 6, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 7, 0, 0, 0, 0, 0, 0, 8],\n            [4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 1],\n            [4, 0, 8, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 7, 0, 0, 0, 0, 0, 0, 8],\n            [4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 7, 0, 0, 0, 7, 7, 7, 1],\n            [4, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 5, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 1],\n            [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],\n            [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4],\n            [6, 6, 6, 6, 6, 6, 0, 6, 6, 6, 6, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],\n            [4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 6, 0, 6, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3],\n            [4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 6, 0, 6, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2],\n            [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 0, 0, 5, 0, 0, 2, 0, 0, 0, 2],\n            [4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 6, 0, 6, 2, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2],\n            [4, 0, 6, 0, 6, 0, 0, 0, 0, 4, 6, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 2],\n            [4, 0, 0, 5, 0, 0, 0, 0, 0, 4, 6, 0, 6, 2, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2],\n            [4, 0, 6, 0, 6, 0, 0, 0, 0, 4, 6, 0, 6, 2, 0, 0, 5, 0, 0, 2, 0, 0, 0, 2],\n            [4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 6, 0, 6, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2],\n            [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3]\n        ]\n    ]\n    return maps[map_number]\n\n\ndef main():\n    raycasting = RaycastingEngine(SCREEN_WIDTH, SCREEN_HEIGHT, \"Raycasting Engine\")\n    raycasting.setup((22, 12), (-1, 0), (0, 0.66), pick_map(1), )\n\n    arcade.run()\n\n\nif __name__ == \"__main__\":\n    main()\nelse:\n    pass\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- raycasting.py	(revision cd56a9af9f628f7b633302f192a4e9e0e6fb5893)
+++ raycasting.py	(date 1588381842727)
@@ -7,7 +7,9 @@
 SCREEN_HEIGHT = 720
 
 MOVE_SPEED = 5.0
-ROTATION_SPEED = 2.0
+ROTATION_SPEED = 1.0
+
+MOTION_PERSISTENCE = 3
 
 
 class RaycastingEngine(arcade.Window):
@@ -15,8 +17,16 @@
     This class creates an arcade window subclass, RaycastingEngine, meant for first-person games
     """
 
-    def __init__(self, width, height, title):
-        super().__init__(width, height, title)
+    def __init__(self, width, height, title, fullscreen=True):
+        super().__init__(width, height, title, fullscreen=fullscreen)
+
+        # set the window to fullscreen by default
+
+        width, height = self.get_size()
+        self.set_viewport(0, width, 0, height)
+
+        # save the window size so we can reference it later
+        self.screen_width, self.screen_height = self.get_size()
 
         # level map
         self.map = None
@@ -39,6 +49,14 @@
         self.rotate_left = None
         self.rotate_right = None
 
+        self.mouse_look = None
+        self.last_x = None
+        self.last_y = None  # currently no implementation for this, just a placeholder
+        self.rotate_x_magnitude = None
+        self.rotate_y_magnitude = None  # currently no implementation for this, just a placeholder
+
+        self.last_frame = None
+
         # performance statistics
         self.time = None
         self.old_time = None
@@ -91,6 +109,14 @@
         self.rotate_left = False
         self.rotate_right = False
 
+        self.mouse_look = False
+        self.last_x = self.screen_width // 2
+        self.last_y = self.screen_height // 2
+        self.rotate_x_magnitude = 1
+        self.rotate_y_magnitude = 1
+
+        self.last_frame = []
+
         # performance statistics
         self.time = 0
         self.old_time = 0
@@ -126,7 +152,9 @@
 
         # hide the mouse by default
         if hide_mouse:
-            self.set_exclusive_mouse(exclusive=True)
+            self.set_mouse_visible(False)
+        else:
+            self.set_mouse_visible(True)
 
         # gameplay
         self.constant_move_speed = player_move_speed
@@ -138,14 +166,14 @@
 
         # set the floor and ceiling colors
         floor = arcade.create_rectangle(
-            SCREEN_WIDTH // 2, int(SCREEN_HEIGHT * 0.25),
-            SCREEN_WIDTH, SCREEN_HEIGHT // 2,
+            self.screen_width // 2, int(self.screen_height * 0.25),
+            self.screen_width, self.screen_height // 2,
             self.floor_color
         )
 
         ceiling = arcade.create_rectangle(
-            SCREEN_WIDTH // 2, int(SCREEN_HEIGHT * 0.75),
-            SCREEN_WIDTH, SCREEN_HEIGHT // 2,
+            self.screen_width // 2, int(self.screen_height * 0.75),
+            self.screen_width, self.screen_height // 2,
             self.ceiling_color
         )
 
@@ -158,9 +186,9 @@
         color_list = []
 
         # begin raycasting
-        for x in range(0, SCREEN_WIDTH + 1):
+        for x in range(0, self.screen_width + 1):
             # calculate the ray position and direction
-            camera_x = (2 * x / SCREEN_WIDTH) - 1
+            camera_x = (2 * x / self.screen_width) - 1
             if camera_x > 1 or camera_x < -1:
                 print('camera_x is too big or too small!')
                 print(f'camera_x = {camera_x}')
@@ -250,17 +278,17 @@
             **********************************************
             """
             # the height of the wall at the given pixel column
-            line_height = int(SCREEN_HEIGHT / (perpendicular_wall_dist + 0.00000001))
+            line_height = int(self.screen_height / (perpendicular_wall_dist + 0.00000001))
 
             # the pixel (height) at which to start drawing the wall
-            draw_start = -line_height / 2 + SCREEN_HEIGHT / 2
+            draw_start = -line_height / 2 + self.screen_height / 2
 
             if draw_start < 0:
                 draw_start = 0
 
-            draw_end = line_height / 2 + SCREEN_HEIGHT / 2
-            if draw_end >= SCREEN_HEIGHT:
-                draw_end = SCREEN_HEIGHT - 1
+            draw_end = line_height / 2 + self.screen_height / 2
+            if draw_end >= self.screen_height:
+                draw_end = self.screen_height - 1
 
             # set the color with which to draw the given pixel column
             if side == 0:
@@ -299,6 +327,8 @@
 
         self.move_speed = frame_time * self.constant_move_speed
         self.rotation_speed = frame_time * self.constant_rotation_speed
+        #print(f'constant rotation speed: {self.constant_rotation_speed}\nframe time: {frame_time}\nadjusted rotation speed: {self.rotation_speed}')
+        self.rotation_speed *= (self.rotate_x_magnitude/100)
 
         if self.move_forward:
             if not self.map[int(self.pos_x + self.dir_x * self.move_speed)][int(self.pos_y)]:
@@ -338,6 +368,10 @@
             old_plane_x = self.plane_x
             self.plane_x = self.plane_x * math.cos(-self.rotation_speed) - self.plane_y * math.sin(-self.rotation_speed)
             self.plane_y = old_plane_x * math.sin(-self.rotation_speed) + self.plane_y * math.cos(-self.rotation_speed)
+        if self.mouse_look:
+            self.mouse_look = False
+            self.rotate_right = False
+            self.rotate_left = False
 
     def on_draw(self):
 
@@ -345,6 +379,11 @@
 
         # draw all the shapes in the list
         self.shape_list.draw()
+        if len(self.last_frame) > MOTION_PERSISTENCE:
+            for frame in range(MOTION_PERSISTENCE):
+                self.last_frame[len(self.last_frame) - frame - 1].draw()
+
+        self.last_frame.append(self.shape_list)
 
         """
         ********************************
@@ -382,6 +421,22 @@
         if key == arcade.key.RIGHT:
             self.rotate_right = False
 
+    def on_mouse_motion(self, x, y, dx, dy):
+        self.mouse_look = True
+        if x > self.last_x or (x == self.screen_width-1 and dx >= 0):
+            self.rotate_right = True
+            self.rotate_x_magnitude = abs(dx)
+            print(self.rotate_x_magnitude)
+        elif x < self.last_x or (x == 0 and dx <= 0):
+            self.rotate_left = True
+            self.rotate_x_magnitude = abs(dx)
+            print(self.rotate_x_magnitude)
+
+        self.last_x = x
+
+    def on_mouse_press(self, x, y, button, modifiers):
+        print(f'press: {button} @ ({x}, {y})')
+
 
 def pick_map(map_number: int):
     maps = [
@@ -442,8 +497,8 @@
 
 
 def main():
-    raycasting = RaycastingEngine(SCREEN_WIDTH, SCREEN_HEIGHT, "Raycasting Engine")
-    raycasting.setup((22, 12), (-1, 0), (0, 0.66), pick_map(1), )
+    raycasting = RaycastingEngine(SCREEN_WIDTH, SCREEN_HEIGHT, "Raycasting Engine", fullscreen=True)
+    raycasting.setup((22, 12), (-1, 0), (0, 0.66), pick_map(1), hide_mouse=True, floor_color=arcade.color.LAWN_GREEN, ceiling_color=arcade.color.DEEP_SKY_BLUE)
 
     arcade.run()
 
Index: .idea/raycasting-engine.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"PYTHON_MODULE\" version=\"4\">\n  <component name=\"NewModuleRootManager\">\n    <content url=\"file://$MODULE_DIR$\">\n      <excludeFolder url=\"file://$MODULE_DIR$/venv\" />\n    </content>\n    <orderEntry type=\"jdk\" jdkName=\"Pipenv (raycasting-engine)\" jdkType=\"Python SDK\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n  </component>\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/raycasting-engine.iml	(revision cd56a9af9f628f7b633302f192a4e9e0e6fb5893)
+++ .idea/raycasting-engine.iml	(date 1588381842785)
@@ -7,4 +7,7 @@
     <orderEntry type="jdk" jdkName="Pipenv (raycasting-engine)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
+  <component name="PackageRequirementsSettings">
+    <option name="keepMatchingSpecifier" value="false" />
+  </component>
 </module>
\ No newline at end of file
Index: requirements.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>arcade==2.3.15\nattrs==19.3.0\ncertifi==2020.4.5.1\nchardet==3.0.4\nidna==2.9\nnumpy==1.18.2\nPillow==7.1.1\npyglet==1.5.3\npytiled-parser==0.9.3\nrequests==2.23.0\nurllib3==1.25.9\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- requirements.txt	(revision cd56a9af9f628f7b633302f192a4e9e0e6fb5893)
+++ requirements.txt	(date 1588381842781)
@@ -1,11 +1,11 @@
-arcade==2.3.15
+arcade~=2.3.15
 attrs==19.3.0
 certifi==2020.4.5.1
 chardet==3.0.4
 idna==2.9
-numpy==1.18.2
+numpy~=1.18.3
 Pillow==7.1.1
 pyglet==1.5.3
 pytiled-parser==0.9.3
-requests==2.23.0
+requests~=2.23.0
 urllib3==1.25.9
